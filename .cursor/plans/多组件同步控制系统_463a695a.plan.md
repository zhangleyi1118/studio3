---
name: 多组件同步控制系统
overview: 实现14根伸缩杆（2组）、1个步进电机滑台和1个舵机的百分比同步控制系统，支持主工作模式（执行→停止10s→复位）和调试模式（单独/组合控制），包含30s控制间隙机制。时间统一为15s作为100%基准，百分比时间控制系统在Arduino中实现。
todos:
  - id: update_pins
    content: 更新Function.ino中的引脚定义：组1用D2/D3，组2用D4/D5，添加舵机D9引脚
    status: pending
  - id: pwm_safety
    content: 实现PWM冲突防护机制：确保同组内RPWM和LPWM不会同时导通（双路端子安全）
    status: pending
    dependencies:
      - update_pins
  - id: add_servo
    content: 添加Servo库和舵机控制功能（初始化、角度设置，转不到底没关系）
    status: pending
    dependencies:
      - update_pins
  - id: state_management
    content: 实现状态管理系统：MotionState和SystemState结构体，时间计算函数（统一15s为100%）
    status: pending
    dependencies:
      - update_pins
  - id: main_state_machine
    content: 实现主工作模式状态机：执行→停止10s→复位流程（Arduino中实现）
    status: pending
    dependencies:
      - state_management
      - add_servo
      - pwm_safety
  - id: cooldown_mechanism
    content: 实现30s控制间隙机制（除强制停止s外忽略所有指令）
    status: pending
    dependencies:
      - state_management
  - id: debug_commands
    content: 扩展命令解析支持调试模式：GROUP1/GROUP2/STEPPER/SERVO及组合控制
    status: pending
    dependencies:
      - state_management
  - id: initialization
    content: 实现初始状态设置：伸缩杆居中、舵机0度（步进电机初始状态手动设置，不自动归零）
    status: pending
    dependencies:
      - add_servo
      - state_management
  - id: stepper_tracking
    content: 实现步进电机位置跟踪（软件计数，用于调试模式）
    status: pending
    dependencies:
      - state_management
  - id: update_python
    content: 更新control_test.py支持新命令格式和调试模式
    status: pending
  - id: start_command
    content: 实现START命令支持：START,ACTUATORS/STEPPER/SERVO/ALL，支持单独或组合恢复初始状态
    status: pending
    dependencies:
      - initialization
  - id: remove_auto_init
    content: 修改setup()函数，移除自动初始化，上电后不执行任何动作，等待指令
    status: pending
    dependencies:
      - start_command
---

# 多组件同步控制系统实现方案

## 系统架构

### 硬件组件

- **组1伸缩杆（1-6）**：共用PWM D2/D3，独立EN引脚 D22-D33
- **组2伸缩杆（7-14）**：共用PWM D4/D5，独立EN引脚 D34-D51
- **步进电机滑台**：STEP=D54, DIR=D55, ENA=D56
- **舵机MG996R**：PWM引脚 D9

### 进度定义（100%基准）

**统一时间基准**：15秒作为100%时间（留余量）

- 伸缩杆：10cm（100mm）@ 6mm/s → 理论时间 = 16.67秒，统一到15秒
- 滑台：100cm（1000mm）@ 60mm/s → 理论时间 = 16.67秒，统一到15秒  
- 舵机：180° @ 10°/s → 理论时间 = 18秒，统一到15秒（转不到底没关系）

**时间计算公式**：`duration = 15000ms * percent / 100`

## 实现计划

### 1. 更新引脚定义和分组 ([Function.ino](Machanic/Function.ino))

**修改内容**：

- 更新RPWM_PINS和LPWM_PINS数组，组1用D2/D3，组2用D4/D5
- 确认R_EN_PINS和L_EN_PINS（组2使用D34-D51）
- 添加舵机引脚定义：`SERVO_PIN = 9`
- 添加组控制相关常量

**关键代码位置**：第20-44行

### 2. 实现PWM冲突防护机制（重要！）([Function.ino](Machanic/Function.ino))

**问题**：同组内如果RPWM和LPWM同时有信号，会导致双路端子短路！**防护措施**：

1. **组控制函数**：`moveGroupForward()`和`moveGroupBackward()`确保同组内所有杆同步
2. **状态检查**：在`moveForward()`和`moveBackward()`中，检查同组内其他杆的状态
3. **强制停止冲突杆**：如果检测到同组内有杆在反向运动，先停止它们
4. **PWM互斥保证**：确保RPWM和LPWM永远不会同时有非零值

**关键代码**：

```cpp
void moveGroupForward(uint8_t group, int speed) {
  // 先停止同组内所有杆（确保PWM清零）
  stopGroup(group);
  delay(10);  // 短暂延迟确保PWM完全清零
  // 然后统一启动
  for (uint8_t i = groupStart; i <= groupEnd; i++) {
    digitalWrite(R_EN_PINS[i], HIGH);
    digitalWrite(L_EN_PINS[i], HIGH);
  }
  analogWrite(RPWM_PINS[groupStart], speed);
  analogWrite(LPWM_PINS[groupStart], 0);  // 确保LPWM=0
}

void moveGroupBackward(uint8_t group, int speed) {
  stopGroup(group);
  delay(10);
  for (uint8_t i = groupStart; i <= groupEnd; i++) {
    digitalWrite(R_EN_PINS[i], HIGH);
    digitalWrite(L_EN_PINS[i], HIGH);
  }
  analogWrite(RPWM_PINS[groupStart], 0);  // 确保RPWM=0
  analogWrite(LPWM_PINS[groupStart], speed);
}
```

**关键代码位置**：新增组控制函数，修改moveForward/moveBackward函数

### 3. 添加舵机控制库和初始化 ([Function.ino](Machanic/Function.ino))

**修改内容**：

- 引入`#include <Servo.h>`
- 创建Servo对象：`Servo servo;`
- 在setup()中初始化：`servo.attach(SERVO_PIN); servo.write(0);`
- 添加舵机控制函数：`setServoAngle(int targetAngle, int percent)` - 转不到底没关系，按百分比计算

**关键代码位置**：setup()函数和新增舵机控制函数

### 4. 实现百分比时间控制系统（Arduino中实现）([Function.ino](Function.ino))

**为什么在Arduino中实现**：

- 需要精确的15s、10s计时，Arduino的millis()更可靠
- 需要自动状态机（执行→停止→复位），不依赖PC持续连接
- 30s控制间隙机制需要在Arduino端实现
- 系统可独立运行，PC仅负责发送指令

**核心数据结构**：

```cpp
struct MotionState {
  bool isRunning;
  unsigned long startTime;
  unsigned long duration;  // 毫秒，统一为 15000ms * percent / 100
  char direction;  // 'F' forward, 'B' backward, 'L' left, 'R' right
  int percent;
};

struct SystemState {
  MotionState group1;  // 组1伸缩杆
  MotionState group2;  // 组2伸缩杆
  MotionState stepper; // 步进电机
  MotionState servo;   // 舵机
  unsigned long lastCommandTime;
  bool inCooldown;  // 30s控制间隙
  enum {IDLE, RUNNING, STOPPING, RESETTING} mainState;
  unsigned long stateStartTime;
  int lastPercent;  // 记录上次百分比，用于复位
};
```

**时间计算函数**：

- `calculateDuration(int percent)` - 统一返回 `15000ms * percent / 100`
- 所有组件使用相同的时间基准

**关键代码位置**：新增状态管理模块

### 5. 实现主工作模式状态机 ([Function.ino](Function.ino))

**状态流程**：

```javascript
IDLE → RUNNING(15s*percent) → STOPPING(10s) → RESETTING(15s*percent) → IDLE
```

**实现函数**：

- `executeMainCommand(char dir, int percent)` - 解析`f, 20`格式
- `updateMainStateMachine()` - 在loop()中调用，非阻塞状态更新
- `startMotion(int percent, char direction)` - 启动所有组件（统一15s时间）
- `stopAllMotion()` - 停止所有组件
- `resetMotion(int percent)` - 反向复位（使用相同时间）

**关键代码位置**：loop()函数和新增状态机函数

### 6. 实现控制间隙机制 ([Function.ino](Function.ino))

**逻辑**：

- 每次执行指令后，设置`inCooldown = true`，记录`lastCommandTime`
- 在loop()中检查：`if (millis() - lastCommandTime < 30000) { inCooldown = true; }`
- 解析命令时：`if (inCooldown && cmd != 's') { return; }`（忽略除s外的所有命令）
- 执行`s`命令时：`inCooldown = false;`（清零）

**关键代码位置**：parseCommand()和applyCommand()函数

### 7. 实现调试模式命令解析 ([Function.ino](Function.ino))

**命令格式扩展**：

- `GROUP1,F,20` - 组1前进20%（15s * 20% = 3s）
- `GROUP2,B,50` - 组2后退50%（15s * 50% = 7.5s）
- `STEPPER,L,30` - 步进电机左移30%（L=左，R=右）
- `SERVO,180,50` - 舵机转到180度的50%（即90度）
- `GROUP1+STEPPER,F,20` - 组合控制

**修改parseCommand()函数**：

- 扩展ParsedCommand结构体，添加组件类型字段
- 支持GROUP1/GROUP2/STEPPER/SERVO/ALL等目标
- 支持组合目标（用+连接）

**关键代码位置**：parseCommand()和applyCommand()函数

### 8. 实现初始状态设置 ([Function.ino](Function.ino))

**initSystemState()函数**：

1. 所有伸缩杆：先全部前进到最底（20cm，约33.3秒），然后后退10cm（约16.7秒）→ 居中
2. 舵机：转到0度
3. **步进电机**：不自动归零，由用户通过`STEPPER,R,100`等指令手动设置初始位置

**步进电机位置跟踪**：

- 添加变量：`long stepperPosition = 0;`（步数，右为正，左为负）
- 每次脉冲更新：`stepperPosition += (stepperLeft ? -1 : 1);`
- 用于调试模式的位置反馈，不用于自动归零

**关键代码位置**：setup()函数末尾调用initSystemState()

### 9. 实现START命令支持 ([Function.ino](Machanic/Function.ino))

**命令格式**：

- `START` 或 `START,ALL` - 恢复所有组件到初始状态
- `START,ACTUATORS` - 只恢复伸缩杆（前进20cm，后退10cm，居中）
- `START,STEPPER` - 只重置步进电机位置计数器为0（不实际移动）
- `START,SERVO` - 只恢复舵机到0度
- 支持组合：`START,ACTUATORS+SERVO`

**实现要求**：

- 使用非阻塞状态机实现初始状态恢复
- 在SystemState中添加InitState枚举和initState字段
- 实现`resetToInitialState()`函数和`updateInitStateMachine()`函数
- 在parseCommand()中添加START命令解析
- 在applyCommand()中处理START命令
- START命令不受30s控制间隙限制（或可选择是否受限）

**关键代码位置**：parseCommand()、applyCommand()、新增初始状态恢复函数

### 10. 移除自动初始化 ([Function.ino](Machanic/Function.ino))

**修改内容**：

- 在setup()函数中删除或注释掉`initSystemState()`调用
- 上电后所有组件保持停止状态，不自动执行任何动作
- 舵机只设置角度为0（不运动），步进电机位置计数器重置为0（不实际移动）
- 更新setup()中的提示信息，说明START命令用法

**关键代码位置**：setup()函数

### 11. 更新Python控制脚本 ([control_test.py](Machanic/control_test.py))

**修改内容**：

- 支持新命令格式：`f, 20`（主模式）和`GROUP1,F,20`（调试模式）
- 添加命令提示和帮助信息
- 实时显示系统状态反馈
- **注意**：Python脚本仅负责发送命令和接收反馈，时间控制逻辑在Arduino中

**关键代码位置**：main()函数的命令输入和处理部分

## 文件修改清单

1. **[Machanic/Function.ino](Machanic/Function.ino)**

- 更新引脚定义（组1/组2，舵机）
- **实现PWM冲突防护机制（重要！）**
- 添加Servo库和舵机控制
- 实现状态管理系统（Arduino中）
- 实现主工作模式状态机（Arduino中）
- 实现控制间隙机制（Arduino中）
- 扩展命令解析（调试模式）
- 实现初始状态设置（步进电机手动设置）
- 添加步进电机位置跟踪（用于调试）

2. **[Machanic/control_test.py](Machanic/control_test.py)**

- 更新命令格式支持
- 添加调试模式命令提示
- 改进用户界面和反馈

## 关键技术点

1. **PWM冲突防护（关键！）**：

- 同组内所有杆必须同步运动
- 确保RPWM和LPWM永远不会同时有非零值
- 在改变方向前先停止所有杆，短暂延迟后再启动

2. **非阻塞时间控制**：使用millis()而非delay()
3. **状态机设计**：主工作模式使用状态机管理复杂流程
4. **统一时间基准**：所有组件统一使用15秒作为100%时间
5. **Arduino端实现**：百分比时间控制、状态机、控制间隙都在Arduino中实现，确保独立运行
6. **步进电机位置跟踪**：软件计数，仅用于调试模式反馈，不用于自动归零

## 潜在问题和注意事项

1. **PWM冲突风险（严重！）**：

- 如果同组内RPWM和LPWM同时有信号，会导致双路端子短路
- **必须通过组控制函数确保同组内所有杆同步**